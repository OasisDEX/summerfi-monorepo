/* eslint-disable @typescript-eslint/no-unused-vars */
import {
  Percentage,
  TokenAmount,
  TokenSymbol,
  Price,
  RiskRatio,
  Address,
  Position,
  ChainId,
  ChainFamilyName,
  valuesOfChainFamilyMap,
} from '@summerfi/sdk-common/common'
import { PoolType, ProtocolName } from '@summerfi/sdk-common/protocols'
import { SimulationSteps } from '@summerfi/sdk-common/simulation'
import type { {{ name }}PoolId } from '@summerfi/sdk-common/protocols'
import { stringToHex, getContract } from 'viem'
import { BigNumber } from 'bignumber.js'
import { z } from 'zod'
import { {{ name }}PaybackWithdrawActionBuilder } from './builders/{{ name }}PaybackWithdrawActionBuilder'
import { BaseProtocolPlugin } from '../implementation/BaseProtocolPlugin'
import { IPositionId } from '../interfaces/IPositionId'
import { {{ name }}LendingPool, {{ name }}PoolCollateralConfig, {{ name }}PoolDebtConfig } from './Types'
import { ERC20_ABI } from './abis'
import { PRECISION_BI, PRECISION } from '../implementation/constants'

export class {{ name }}ProtocolPlugin extends BaseProtocolPlugin<{{ name }}PoolId> {
  readonly protocol: ProtocolName.{{ name }} = ProtocolName.{{ name }}
  readonly supportedChains = valuesOfChainFamilyMap([ChainFamilyName.Ethereum])
  readonly schema = z.object({
    protocol: z.object({
      name: z.literal(ProtocolName.{{ name }}),
      chainInfo: z.object({
        name: z.string(),
        chainId: z.custom<ChainId>(
          (chainId) =>
            this.supportedChains.some((chainInfo) => chainInfo.chainId === chainId),
          'Chain ID not supported',
          true,
        ),
      }),
    })
  })
  readonly StepBuildersMap = {
     [SimulationSteps.PaybackWithdraw]: {{ name }}PaybackWithdrawActionBuilder,
     [SimulationSteps.DepositBorrow]: {{ name }}DepositBorrowActionBuilder,
  }

  async getPool({{ nameCamelCase }}PoolId: unknown): Promise<{{ name }}LendingPool> {
    this.isPoolId({{ nameCamelCase }}PoolId)

    const ctx = this.ctx
    const chainId = ctx.provider.chain?.id
    if (!chainId) throw new Error('ctx.provider.chain.id undefined')

    if (!{{ name }}ProtocolPlugin.supportedChains.some((chainInfo) => chainInfo.chainId === chainId)) {
      throw new Error(`Chain ID ${chainId} is not supported`)
    }

    const [] = await ctx.provider.multicall({
      contracts: [],
      allowFailure: false,
    })

    const collaterals: Record<string, {{ name }}PoolCollateralConfig> = {
      [collateralToken.address.value]: {
        token: collateralToken,
        price: Price.createFrom({
          // value: osmData.currentPrice,
          baseToken: collateralToken,
          quoteToken: quoteToken,
        }),
        priceUSD: await ctx.priceService.getPriceUSD(collateralToken),

        liquidationThreshold: RiskRatio.createFrom({
          ratio: Percentage.createFrom({
          // percentage: spotRes.liquidationRatio.times(100).toNumber(),
          }),
          // type: RiskRatio.type.CollateralizationRatio,
        }),
      },
    }

    const debts: Record<string, {{ name }}PoolDebtConfig> = {
      [quoteToken.address.value]: {
        token: quoteToken,
        price: await ctx.priceService.getPrice({
          baseToken: quoteToken,
          quoteToken: collateralToken,
        }),
        priceUSD: await ctx.priceService.getPriceUSD(quoteToken),
        // rate: Percentage.createFrom({ percentage: stabilityFee.times(100).toNumber() }),
      },
    }

    return {
      type: PoolType.Lending,
      poolId: {{ nameCamelCase }}PoolId,
      protocol: {{ nameCamelCase }}PoolId.protocol,
      baseCurrency: poolBaseCurrencyToken,
      collaterals,
      debts,
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getPositionId(positionId: string): IPositionId {
    throw new Error('Not implemented')
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async getPosition(positionId: IPositionId): Promise<Position> {
    throw new Error('Not implemented')
  }
}

export const {{ nameCamelCase }}ProtocolPlugin = new {{ name }}ProtocolPlugin()