# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type AnswerUpdated {
    current: BigInt!
    id: Bytes!
    oracle: Oracle!
    roundId: BigInt!
    updatedAt: BigInt!
}

type BasePrice {
    id: Bytes!
    oracle: Oracle!
    price: BigInt!
    roundId: BigInt!
    timestamp: BigInt!
}

type DerivedOracle {
    denomination: Token!
    denominationOracle: Oracle!
    denominationOracleProxy: Bytes!
    description: String!
    id: Bytes!
    prices(first: Int = 100, orderBy: DerivedPrice_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DerivedPrice_filter): [DerivedPrice!]!
    token: Token!
    tokenOracle: Oracle!
    tokenOracleProxy: Bytes!
    tokenPair: DerivedTokenPair!
}

type DerivedPrice {
    day: BigInt
    denomination: Token!
    denominationPrice: BigInt!
    denominationRoundId: BigInt!
    denominationTimestamp: BigInt!
    derivedPrice: BigInt!
    hour: BigInt
    id: Bytes!
    month: BigInt
    oracle: DerivedOracle!
    oracleType: String!
    token: Token!
    tokenPair: DerivedTokenPair!
    tokenPrice: BigInt!
    tokenRoundId: BigInt!
    tokenTimestamp: BigInt!
    year: BigInt
}

type DerivedTokenPair {
    denomination: Token!
    description: String!
    id: Bytes!
    oracle: DerivedOracle!
    prices(first: Int = 100, orderBy: DerivedPrice_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DerivedPrice_filter): [DerivedPrice!]!
    token: Token!
}

type Oracle {
    address: Bytes!
    denomintaion: Token!
    description: String!
    id: Bytes!
    prices(first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Price_filter): [Price!]!
    token: Token!
    tokenPair: TokenPair!
}

type Price {
    day: BigInt
    hour: BigInt
    id: Bytes!
    month: BigInt
    oracle: Oracle!
    oracleType: String!
    price: BigInt!
    roundId: BigInt
    timestamp: BigInt!
    token: Token!
    tokenPair: TokenPair!
    year: BigInt
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    answerUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AnswerUpdated
    answerUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerUpdated_filter
    ): [AnswerUpdated!]!
    basePrice(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BasePrice
    basePrices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BasePrice_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BasePrice_filter
    ): [BasePrice!]!
    derivedOracle(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedOracle
    derivedOracles(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedOracle_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedOracle_filter
    ): [DerivedOracle!]!
    derivedPrice(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedPrice
    derivedPrices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedPrice_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedPrice_filter
    ): [DerivedPrice!]!
    derivedTokenPair(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedTokenPair
    derivedTokenPairs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedTokenPair_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedTokenPair_filter
    ): [DerivedTokenPair!]!
    oracle(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Oracle
    oracles(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Oracle_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Oracle_filter
    ): [Oracle!]!
    price(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Price
    prices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Price_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Price_filter
    ): [Price!]!
    state(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): State
    states(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: State_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: State_filter
    ): [State!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenPair(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenPair
    tokenPairs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenPair_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenPair_filter
    ): [TokenPair!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type State {
    id: Bytes!
    lastUpdateTimestamp: BigInt
    oraclesInitialized: Boolean!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    answerUpdated(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AnswerUpdated
    answerUpdateds(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AnswerUpdated_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AnswerUpdated_filter
    ): [AnswerUpdated!]!
    basePrice(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BasePrice
    basePrices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BasePrice_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BasePrice_filter
    ): [BasePrice!]!
    derivedOracle(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedOracle
    derivedOracles(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedOracle_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedOracle_filter
    ): [DerivedOracle!]!
    derivedPrice(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedPrice
    derivedPrices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedPrice_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedPrice_filter
    ): [DerivedPrice!]!
    derivedTokenPair(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DerivedTokenPair
    derivedTokenPairs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DerivedTokenPair_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DerivedTokenPair_filter
    ): [DerivedTokenPair!]!
    oracle(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Oracle
    oracles(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Oracle_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Oracle_filter
    ): [Oracle!]!
    price(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Price
    prices(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Price_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Price_filter
    ): [Price!]!
    state(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): State
    states(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: State_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: State_filter
    ): [State!]!
    token(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Token
    tokenPair(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenPair
    tokenPairs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenPair_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenPair_filter
    ): [TokenPair!]!
    tokens(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Token_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Token_filter
    ): [Token!]!
}

type Token {
    address: Bytes!
    decimals: BigInt!
    id: Bytes!
    oraclesDenomination(first: Int = 100, orderBy: Oracle_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Oracle_filter): [Oracle!]!
    oraclesToken(first: Int = 100, orderBy: Oracle_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Oracle_filter): [Oracle!]!
    precision: BigInt!
    prices(first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Price_filter): [Price!]!
    symbol: String!
    tokenPairs(first: Int = 100, orderBy: TokenPair_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenPair_filter): [TokenPair!]!
}

type TokenPair {
    denomination: Token!
    description: String!
    id: Bytes!
    oracle: Oracle!
    prices(first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Price_filter): [Price!]!
    token: Token!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum AnswerUpdated_orderBy {
    current
    id
    oracle
    oracle__address
    oracle__description
    oracle__id
    roundId
    updatedAt
}

enum BasePrice_orderBy {
    id
    oracle
    oracle__address
    oracle__description
    oracle__id
    price
    roundId
    timestamp
}

enum DerivedOracle_orderBy {
    denomination
    denominationOracle
    denominationOracleProxy
    denominationOracle__address
    denominationOracle__description
    denominationOracle__id
    denomination__address
    denomination__decimals
    denomination__id
    denomination__precision
    denomination__symbol
    description
    id
    prices
    token
    tokenOracle
    tokenOracleProxy
    tokenOracle__address
    tokenOracle__description
    tokenOracle__id
    tokenPair
    tokenPair__description
    tokenPair__id
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
}

enum DerivedPrice_orderBy {
    day
    denomination
    denominationPrice
    denominationRoundId
    denominationTimestamp
    denomination__address
    denomination__decimals
    denomination__id
    denomination__precision
    denomination__symbol
    derivedPrice
    hour
    id
    month
    oracle
    oracleType
    oracle__denominationOracleProxy
    oracle__description
    oracle__id
    oracle__tokenOracleProxy
    token
    tokenPair
    tokenPair__description
    tokenPair__id
    tokenPrice
    tokenRoundId
    tokenTimestamp
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
    year
}

enum DerivedTokenPair_orderBy {
    denomination
    denomination__address
    denomination__decimals
    denomination__id
    denomination__precision
    denomination__symbol
    description
    id
    oracle
    oracle__denominationOracleProxy
    oracle__description
    oracle__id
    oracle__tokenOracleProxy
    prices
    token
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
}

enum Oracle_orderBy {
    address
    denomintaion
    denomintaion__address
    denomintaion__decimals
    denomintaion__id
    denomintaion__precision
    denomintaion__symbol
    description
    id
    prices
    token
    tokenPair
    tokenPair__description
    tokenPair__id
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum Price_orderBy {
    day
    hour
    id
    month
    oracle
    oracleType
    oracle__address
    oracle__description
    oracle__id
    price
    roundId
    timestamp
    token
    tokenPair
    tokenPair__description
    tokenPair__id
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
    year
}

enum State_orderBy {
    id
    lastUpdateTimestamp
    oraclesInitialized
}

enum TokenPair_orderBy {
    denomination
    denomination__address
    denomination__decimals
    denomination__id
    denomination__precision
    denomination__symbol
    description
    id
    oracle
    oracle__address
    oracle__description
    oracle__id
    prices
    token
    token__address
    token__decimals
    token__id
    token__precision
    token__symbol
}

enum Token_orderBy {
    address
    decimals
    id
    oraclesDenomination
    oraclesToken
    precision
    prices
    symbol
    tokenPairs
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input AnswerUpdated_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [AnswerUpdated_filter]
    current: BigInt
    current_gt: BigInt
    current_gte: BigInt
    current_in: [BigInt!]
    current_lt: BigInt
    current_lte: BigInt
    current_not: BigInt
    current_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [AnswerUpdated_filter]
    oracle: String
    oracle_: Oracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    roundId: BigInt
    roundId_gt: BigInt
    roundId_gte: BigInt
    roundId_in: [BigInt!]
    roundId_lt: BigInt
    roundId_lte: BigInt
    roundId_not: BigInt
    roundId_not_in: [BigInt!]
    updatedAt: BigInt
    updatedAt_gt: BigInt
    updatedAt_gte: BigInt
    updatedAt_in: [BigInt!]
    updatedAt_lt: BigInt
    updatedAt_lte: BigInt
    updatedAt_not: BigInt
    updatedAt_not_in: [BigInt!]
}

input BasePrice_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [BasePrice_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [BasePrice_filter]
    oracle: String
    oracle_: Oracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    price: BigInt
    price_gt: BigInt
    price_gte: BigInt
    price_in: [BigInt!]
    price_lt: BigInt
    price_lte: BigInt
    price_not: BigInt
    price_not_in: [BigInt!]
    roundId: BigInt
    roundId_gt: BigInt
    roundId_gte: BigInt
    roundId_in: [BigInt!]
    roundId_lt: BigInt
    roundId_lte: BigInt
    roundId_not: BigInt
    roundId_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input DerivedOracle_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DerivedOracle_filter]
    denomination: String
    denominationOracle: String
    denominationOracleProxy: Bytes
    denominationOracleProxy_contains: Bytes
    denominationOracleProxy_gt: Bytes
    denominationOracleProxy_gte: Bytes
    denominationOracleProxy_in: [Bytes!]
    denominationOracleProxy_lt: Bytes
    denominationOracleProxy_lte: Bytes
    denominationOracleProxy_not: Bytes
    denominationOracleProxy_not_contains: Bytes
    denominationOracleProxy_not_in: [Bytes!]
    denominationOracle_: Oracle_filter
    denominationOracle_contains: String
    denominationOracle_contains_nocase: String
    denominationOracle_ends_with: String
    denominationOracle_ends_with_nocase: String
    denominationOracle_gt: String
    denominationOracle_gte: String
    denominationOracle_in: [String!]
    denominationOracle_lt: String
    denominationOracle_lte: String
    denominationOracle_not: String
    denominationOracle_not_contains: String
    denominationOracle_not_contains_nocase: String
    denominationOracle_not_ends_with: String
    denominationOracle_not_ends_with_nocase: String
    denominationOracle_not_in: [String!]
    denominationOracle_not_starts_with: String
    denominationOracle_not_starts_with_nocase: String
    denominationOracle_starts_with: String
    denominationOracle_starts_with_nocase: String
    denomination_: Token_filter
    denomination_contains: String
    denomination_contains_nocase: String
    denomination_ends_with: String
    denomination_ends_with_nocase: String
    denomination_gt: String
    denomination_gte: String
    denomination_in: [String!]
    denomination_lt: String
    denomination_lte: String
    denomination_not: String
    denomination_not_contains: String
    denomination_not_contains_nocase: String
    denomination_not_ends_with: String
    denomination_not_ends_with_nocase: String
    denomination_not_in: [String!]
    denomination_not_starts_with: String
    denomination_not_starts_with_nocase: String
    denomination_starts_with: String
    denomination_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [DerivedOracle_filter]
    prices_: DerivedPrice_filter
    token: String
    tokenOracle: String
    tokenOracleProxy: Bytes
    tokenOracleProxy_contains: Bytes
    tokenOracleProxy_gt: Bytes
    tokenOracleProxy_gte: Bytes
    tokenOracleProxy_in: [Bytes!]
    tokenOracleProxy_lt: Bytes
    tokenOracleProxy_lte: Bytes
    tokenOracleProxy_not: Bytes
    tokenOracleProxy_not_contains: Bytes
    tokenOracleProxy_not_in: [Bytes!]
    tokenOracle_: Oracle_filter
    tokenOracle_contains: String
    tokenOracle_contains_nocase: String
    tokenOracle_ends_with: String
    tokenOracle_ends_with_nocase: String
    tokenOracle_gt: String
    tokenOracle_gte: String
    tokenOracle_in: [String!]
    tokenOracle_lt: String
    tokenOracle_lte: String
    tokenOracle_not: String
    tokenOracle_not_contains: String
    tokenOracle_not_contains_nocase: String
    tokenOracle_not_ends_with: String
    tokenOracle_not_ends_with_nocase: String
    tokenOracle_not_in: [String!]
    tokenOracle_not_starts_with: String
    tokenOracle_not_starts_with_nocase: String
    tokenOracle_starts_with: String
    tokenOracle_starts_with_nocase: String
    tokenPair: String
    tokenPair_: DerivedTokenPair_filter
    tokenPair_contains: String
    tokenPair_contains_nocase: String
    tokenPair_ends_with: String
    tokenPair_ends_with_nocase: String
    tokenPair_gt: String
    tokenPair_gte: String
    tokenPair_in: [String!]
    tokenPair_lt: String
    tokenPair_lte: String
    tokenPair_not: String
    tokenPair_not_contains: String
    tokenPair_not_contains_nocase: String
    tokenPair_not_ends_with: String
    tokenPair_not_ends_with_nocase: String
    tokenPair_not_in: [String!]
    tokenPair_not_starts_with: String
    tokenPair_not_starts_with_nocase: String
    tokenPair_starts_with: String
    tokenPair_starts_with_nocase: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input DerivedPrice_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DerivedPrice_filter]
    day: BigInt
    day_gt: BigInt
    day_gte: BigInt
    day_in: [BigInt!]
    day_lt: BigInt
    day_lte: BigInt
    day_not: BigInt
    day_not_in: [BigInt!]
    denomination: String
    denominationPrice: BigInt
    denominationPrice_gt: BigInt
    denominationPrice_gte: BigInt
    denominationPrice_in: [BigInt!]
    denominationPrice_lt: BigInt
    denominationPrice_lte: BigInt
    denominationPrice_not: BigInt
    denominationPrice_not_in: [BigInt!]
    denominationRoundId: BigInt
    denominationRoundId_gt: BigInt
    denominationRoundId_gte: BigInt
    denominationRoundId_in: [BigInt!]
    denominationRoundId_lt: BigInt
    denominationRoundId_lte: BigInt
    denominationRoundId_not: BigInt
    denominationRoundId_not_in: [BigInt!]
    denominationTimestamp: BigInt
    denominationTimestamp_gt: BigInt
    denominationTimestamp_gte: BigInt
    denominationTimestamp_in: [BigInt!]
    denominationTimestamp_lt: BigInt
    denominationTimestamp_lte: BigInt
    denominationTimestamp_not: BigInt
    denominationTimestamp_not_in: [BigInt!]
    denomination_: Token_filter
    denomination_contains: String
    denomination_contains_nocase: String
    denomination_ends_with: String
    denomination_ends_with_nocase: String
    denomination_gt: String
    denomination_gte: String
    denomination_in: [String!]
    denomination_lt: String
    denomination_lte: String
    denomination_not: String
    denomination_not_contains: String
    denomination_not_contains_nocase: String
    denomination_not_ends_with: String
    denomination_not_ends_with_nocase: String
    denomination_not_in: [String!]
    denomination_not_starts_with: String
    denomination_not_starts_with_nocase: String
    denomination_starts_with: String
    denomination_starts_with_nocase: String
    derivedPrice: BigInt
    derivedPrice_gt: BigInt
    derivedPrice_gte: BigInt
    derivedPrice_in: [BigInt!]
    derivedPrice_lt: BigInt
    derivedPrice_lte: BigInt
    derivedPrice_not: BigInt
    derivedPrice_not_in: [BigInt!]
    hour: BigInt
    hour_gt: BigInt
    hour_gte: BigInt
    hour_in: [BigInt!]
    hour_lt: BigInt
    hour_lte: BigInt
    hour_not: BigInt
    hour_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    month: BigInt
    month_gt: BigInt
    month_gte: BigInt
    month_in: [BigInt!]
    month_lt: BigInt
    month_lte: BigInt
    month_not: BigInt
    month_not_in: [BigInt!]
    or: [DerivedPrice_filter]
    oracle: String
    oracleType: String
    oracleType_contains: String
    oracleType_contains_nocase: String
    oracleType_ends_with: String
    oracleType_ends_with_nocase: String
    oracleType_gt: String
    oracleType_gte: String
    oracleType_in: [String!]
    oracleType_lt: String
    oracleType_lte: String
    oracleType_not: String
    oracleType_not_contains: String
    oracleType_not_contains_nocase: String
    oracleType_not_ends_with: String
    oracleType_not_ends_with_nocase: String
    oracleType_not_in: [String!]
    oracleType_not_starts_with: String
    oracleType_not_starts_with_nocase: String
    oracleType_starts_with: String
    oracleType_starts_with_nocase: String
    oracle_: DerivedOracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    token: String
    tokenPair: String
    tokenPair_: DerivedTokenPair_filter
    tokenPair_contains: String
    tokenPair_contains_nocase: String
    tokenPair_ends_with: String
    tokenPair_ends_with_nocase: String
    tokenPair_gt: String
    tokenPair_gte: String
    tokenPair_in: [String!]
    tokenPair_lt: String
    tokenPair_lte: String
    tokenPair_not: String
    tokenPair_not_contains: String
    tokenPair_not_contains_nocase: String
    tokenPair_not_ends_with: String
    tokenPair_not_ends_with_nocase: String
    tokenPair_not_in: [String!]
    tokenPair_not_starts_with: String
    tokenPair_not_starts_with_nocase: String
    tokenPair_starts_with: String
    tokenPair_starts_with_nocase: String
    tokenPrice: BigInt
    tokenPrice_gt: BigInt
    tokenPrice_gte: BigInt
    tokenPrice_in: [BigInt!]
    tokenPrice_lt: BigInt
    tokenPrice_lte: BigInt
    tokenPrice_not: BigInt
    tokenPrice_not_in: [BigInt!]
    tokenRoundId: BigInt
    tokenRoundId_gt: BigInt
    tokenRoundId_gte: BigInt
    tokenRoundId_in: [BigInt!]
    tokenRoundId_lt: BigInt
    tokenRoundId_lte: BigInt
    tokenRoundId_not: BigInt
    tokenRoundId_not_in: [BigInt!]
    tokenTimestamp: BigInt
    tokenTimestamp_gt: BigInt
    tokenTimestamp_gte: BigInt
    tokenTimestamp_in: [BigInt!]
    tokenTimestamp_lt: BigInt
    tokenTimestamp_lte: BigInt
    tokenTimestamp_not: BigInt
    tokenTimestamp_not_in: [BigInt!]
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    year: BigInt
    year_gt: BigInt
    year_gte: BigInt
    year_in: [BigInt!]
    year_lt: BigInt
    year_lte: BigInt
    year_not: BigInt
    year_not_in: [BigInt!]
}

input DerivedTokenPair_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DerivedTokenPair_filter]
    denomination: String
    denomination_: Token_filter
    denomination_contains: String
    denomination_contains_nocase: String
    denomination_ends_with: String
    denomination_ends_with_nocase: String
    denomination_gt: String
    denomination_gte: String
    denomination_in: [String!]
    denomination_lt: String
    denomination_lte: String
    denomination_not: String
    denomination_not_contains: String
    denomination_not_contains_nocase: String
    denomination_not_ends_with: String
    denomination_not_ends_with_nocase: String
    denomination_not_in: [String!]
    denomination_not_starts_with: String
    denomination_not_starts_with_nocase: String
    denomination_starts_with: String
    denomination_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [DerivedTokenPair_filter]
    oracle: String
    oracle_: DerivedOracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    prices_: DerivedPrice_filter
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Oracle_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Oracle_filter]
    denomintaion: String
    denomintaion_: Token_filter
    denomintaion_contains: String
    denomintaion_contains_nocase: String
    denomintaion_ends_with: String
    denomintaion_ends_with_nocase: String
    denomintaion_gt: String
    denomintaion_gte: String
    denomintaion_in: [String!]
    denomintaion_lt: String
    denomintaion_lte: String
    denomintaion_not: String
    denomintaion_not_contains: String
    denomintaion_not_contains_nocase: String
    denomintaion_not_ends_with: String
    denomintaion_not_ends_with_nocase: String
    denomintaion_not_in: [String!]
    denomintaion_not_starts_with: String
    denomintaion_not_starts_with_nocase: String
    denomintaion_starts_with: String
    denomintaion_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Oracle_filter]
    prices_: Price_filter
    token: String
    tokenPair: String
    tokenPair_: TokenPair_filter
    tokenPair_contains: String
    tokenPair_contains_nocase: String
    tokenPair_ends_with: String
    tokenPair_ends_with_nocase: String
    tokenPair_gt: String
    tokenPair_gte: String
    tokenPair_in: [String!]
    tokenPair_lt: String
    tokenPair_lte: String
    tokenPair_not: String
    tokenPair_not_contains: String
    tokenPair_not_contains_nocase: String
    tokenPair_not_ends_with: String
    tokenPair_not_ends_with_nocase: String
    tokenPair_not_in: [String!]
    tokenPair_not_starts_with: String
    tokenPair_not_starts_with_nocase: String
    tokenPair_starts_with: String
    tokenPair_starts_with_nocase: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Price_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Price_filter]
    day: BigInt
    day_gt: BigInt
    day_gte: BigInt
    day_in: [BigInt!]
    day_lt: BigInt
    day_lte: BigInt
    day_not: BigInt
    day_not_in: [BigInt!]
    hour: BigInt
    hour_gt: BigInt
    hour_gte: BigInt
    hour_in: [BigInt!]
    hour_lt: BigInt
    hour_lte: BigInt
    hour_not: BigInt
    hour_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    month: BigInt
    month_gt: BigInt
    month_gte: BigInt
    month_in: [BigInt!]
    month_lt: BigInt
    month_lte: BigInt
    month_not: BigInt
    month_not_in: [BigInt!]
    or: [Price_filter]
    oracle: String
    oracleType: String
    oracleType_contains: String
    oracleType_contains_nocase: String
    oracleType_ends_with: String
    oracleType_ends_with_nocase: String
    oracleType_gt: String
    oracleType_gte: String
    oracleType_in: [String!]
    oracleType_lt: String
    oracleType_lte: String
    oracleType_not: String
    oracleType_not_contains: String
    oracleType_not_contains_nocase: String
    oracleType_not_ends_with: String
    oracleType_not_ends_with_nocase: String
    oracleType_not_in: [String!]
    oracleType_not_starts_with: String
    oracleType_not_starts_with_nocase: String
    oracleType_starts_with: String
    oracleType_starts_with_nocase: String
    oracle_: Oracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    price: BigInt
    price_gt: BigInt
    price_gte: BigInt
    price_in: [BigInt!]
    price_lt: BigInt
    price_lte: BigInt
    price_not: BigInt
    price_not_in: [BigInt!]
    roundId: BigInt
    roundId_gt: BigInt
    roundId_gte: BigInt
    roundId_in: [BigInt!]
    roundId_lt: BigInt
    roundId_lte: BigInt
    roundId_not: BigInt
    roundId_not_in: [BigInt!]
    timestamp: BigInt
    timestamp_gt: BigInt
    timestamp_gte: BigInt
    timestamp_in: [BigInt!]
    timestamp_lt: BigInt
    timestamp_lte: BigInt
    timestamp_not: BigInt
    timestamp_not_in: [BigInt!]
    token: String
    tokenPair: String
    tokenPair_: TokenPair_filter
    tokenPair_contains: String
    tokenPair_contains_nocase: String
    tokenPair_ends_with: String
    tokenPair_ends_with_nocase: String
    tokenPair_gt: String
    tokenPair_gte: String
    tokenPair_in: [String!]
    tokenPair_lt: String
    tokenPair_lte: String
    tokenPair_not: String
    tokenPair_not_contains: String
    tokenPair_not_contains_nocase: String
    tokenPair_not_ends_with: String
    tokenPair_not_ends_with_nocase: String
    tokenPair_not_in: [String!]
    tokenPair_not_starts_with: String
    tokenPair_not_starts_with_nocase: String
    tokenPair_starts_with: String
    tokenPair_starts_with_nocase: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
    year: BigInt
    year_gt: BigInt
    year_gte: BigInt
    year_in: [BigInt!]
    year_lt: BigInt
    year_lte: BigInt
    year_not: BigInt
    year_not_in: [BigInt!]
}

input State_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [State_filter]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    lastUpdateTimestamp: BigInt
    lastUpdateTimestamp_gt: BigInt
    lastUpdateTimestamp_gte: BigInt
    lastUpdateTimestamp_in: [BigInt!]
    lastUpdateTimestamp_lt: BigInt
    lastUpdateTimestamp_lte: BigInt
    lastUpdateTimestamp_not: BigInt
    lastUpdateTimestamp_not_in: [BigInt!]
    or: [State_filter]
    oraclesInitialized: Boolean
    oraclesInitialized_in: [Boolean!]
    oraclesInitialized_not: Boolean
    oraclesInitialized_not_in: [Boolean!]
}

input TokenPair_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TokenPair_filter]
    denomination: String
    denomination_: Token_filter
    denomination_contains: String
    denomination_contains_nocase: String
    denomination_ends_with: String
    denomination_ends_with_nocase: String
    denomination_gt: String
    denomination_gte: String
    denomination_in: [String!]
    denomination_lt: String
    denomination_lte: String
    denomination_not: String
    denomination_not_contains: String
    denomination_not_contains_nocase: String
    denomination_not_ends_with: String
    denomination_not_ends_with_nocase: String
    denomination_not_in: [String!]
    denomination_not_starts_with: String
    denomination_not_starts_with_nocase: String
    denomination_starts_with: String
    denomination_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [TokenPair_filter]
    oracle: String
    oracle_: Oracle_filter
    oracle_contains: String
    oracle_contains_nocase: String
    oracle_ends_with: String
    oracle_ends_with_nocase: String
    oracle_gt: String
    oracle_gte: String
    oracle_in: [String!]
    oracle_lt: String
    oracle_lte: String
    oracle_not: String
    oracle_not_contains: String
    oracle_not_contains_nocase: String
    oracle_not_ends_with: String
    oracle_not_ends_with_nocase: String
    oracle_not_in: [String!]
    oracle_not_starts_with: String
    oracle_not_starts_with_nocase: String
    oracle_starts_with: String
    oracle_starts_with_nocase: String
    prices_: Price_filter
    token: String
    token_: Token_filter
    token_contains: String
    token_contains_nocase: String
    token_ends_with: String
    token_ends_with_nocase: String
    token_gt: String
    token_gte: String
    token_in: [String!]
    token_lt: String
    token_lte: String
    token_not: String
    token_not_contains: String
    token_not_contains_nocase: String
    token_not_ends_with: String
    token_not_ends_with_nocase: String
    token_not_in: [String!]
    token_not_starts_with: String
    token_not_starts_with_nocase: String
    token_starts_with: String
    token_starts_with_nocase: String
}

input Token_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    address: Bytes
    address_contains: Bytes
    address_gt: Bytes
    address_gte: Bytes
    address_in: [Bytes!]
    address_lt: Bytes
    address_lte: Bytes
    address_not: Bytes
    address_not_contains: Bytes
    address_not_in: [Bytes!]
    and: [Token_filter]
    decimals: BigInt
    decimals_gt: BigInt
    decimals_gte: BigInt
    decimals_in: [BigInt!]
    decimals_lt: BigInt
    decimals_lte: BigInt
    decimals_not: BigInt
    decimals_not_in: [BigInt!]
    id: Bytes
    id_contains: Bytes
    id_gt: Bytes
    id_gte: Bytes
    id_in: [Bytes!]
    id_lt: Bytes
    id_lte: Bytes
    id_not: Bytes
    id_not_contains: Bytes
    id_not_in: [Bytes!]
    or: [Token_filter]
    oraclesDenomination_: Oracle_filter
    oraclesToken_: Oracle_filter
    precision: BigInt
    precision_gt: BigInt
    precision_gte: BigInt
    precision_in: [BigInt!]
    precision_lt: BigInt
    precision_lte: BigInt
    precision_not: BigInt
    precision_not_in: [BigInt!]
    prices_: Price_filter
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    tokenPairs_: TokenPair_filter
}
