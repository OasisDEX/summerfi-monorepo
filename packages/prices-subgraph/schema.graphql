"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity
is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type _Block_ {
  """The hash of the block"""
  hash: Bytes

  """The block number"""
  number: Int!

  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!

  """The deployment ID"""
  deployment: String!

  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow

  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}

type AnswerUpdated {
  id: Bytes!
  current: BigInt!
  roundId: BigInt!
  aggregatorRoundId: BigInt!
  updatedAt: BigInt!
  oracle: Oracle!
}

input AnswerUpdated_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  current: BigInt
  current_not: BigInt
  current_gt: BigInt
  current_lt: BigInt
  current_gte: BigInt
  current_lte: BigInt
  current_in: [BigInt!]
  current_not_in: [BigInt!]
  roundId: BigInt
  roundId_not: BigInt
  roundId_gt: BigInt
  roundId_lt: BigInt
  roundId_gte: BigInt
  roundId_lte: BigInt
  roundId_in: [BigInt!]
  roundId_not_in: [BigInt!]
  aggregatorRoundId: BigInt
  aggregatorRoundId_not: BigInt
  aggregatorRoundId_gt: BigInt
  aggregatorRoundId_lt: BigInt
  aggregatorRoundId_gte: BigInt
  aggregatorRoundId_lte: BigInt
  aggregatorRoundId_in: [BigInt!]
  aggregatorRoundId_not_in: [BigInt!]
  updatedAt: BigInt
  updatedAt_not: BigInt
  updatedAt_gt: BigInt
  updatedAt_lt: BigInt
  updatedAt_gte: BigInt
  updatedAt_lte: BigInt
  updatedAt_in: [BigInt!]
  updatedAt_not_in: [BigInt!]
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: Oracle_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [AnswerUpdated_filter]
  or: [AnswerUpdated_filter]
}

enum AnswerUpdated_orderBy {
  id
  current
  roundId
  aggregatorRoundId
  updatedAt
  oracle
  oracle__id
  oracle__address
  oracle__description
  oracle__phaseId
}

scalar BigDecimal

scalar BigInt

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

input BlockChangedFilter {
  number_gte: Int!
}

scalar Bytes

type DerivedOracle {
  id: Bytes!
  token: Token!
  denomination: Token!
  tokenOracle: Oracle!
  denominationOracle: Oracle!
  tokenPair: DerivedTokenPair!
  description: String!
  prices(skip: Int = 0, first: Int = 100, orderBy: DerivedPrice_orderBy, orderDirection: OrderDirection, where: DerivedPrice_filter): [DerivedPrice!]!
}

input DerivedOracle_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  denomination: String
  denomination_not: String
  denomination_gt: String
  denomination_lt: String
  denomination_gte: String
  denomination_lte: String
  denomination_in: [String!]
  denomination_not_in: [String!]
  denomination_contains: String
  denomination_contains_nocase: String
  denomination_not_contains: String
  denomination_not_contains_nocase: String
  denomination_starts_with: String
  denomination_starts_with_nocase: String
  denomination_not_starts_with: String
  denomination_not_starts_with_nocase: String
  denomination_ends_with: String
  denomination_ends_with_nocase: String
  denomination_not_ends_with: String
  denomination_not_ends_with_nocase: String
  denomination_: Token_filter
  tokenOracle: String
  tokenOracle_not: String
  tokenOracle_gt: String
  tokenOracle_lt: String
  tokenOracle_gte: String
  tokenOracle_lte: String
  tokenOracle_in: [String!]
  tokenOracle_not_in: [String!]
  tokenOracle_contains: String
  tokenOracle_contains_nocase: String
  tokenOracle_not_contains: String
  tokenOracle_not_contains_nocase: String
  tokenOracle_starts_with: String
  tokenOracle_starts_with_nocase: String
  tokenOracle_not_starts_with: String
  tokenOracle_not_starts_with_nocase: String
  tokenOracle_ends_with: String
  tokenOracle_ends_with_nocase: String
  tokenOracle_not_ends_with: String
  tokenOracle_not_ends_with_nocase: String
  tokenOracle_: Oracle_filter
  denominationOracle: String
  denominationOracle_not: String
  denominationOracle_gt: String
  denominationOracle_lt: String
  denominationOracle_gte: String
  denominationOracle_lte: String
  denominationOracle_in: [String!]
  denominationOracle_not_in: [String!]
  denominationOracle_contains: String
  denominationOracle_contains_nocase: String
  denominationOracle_not_contains: String
  denominationOracle_not_contains_nocase: String
  denominationOracle_starts_with: String
  denominationOracle_starts_with_nocase: String
  denominationOracle_not_starts_with: String
  denominationOracle_not_starts_with_nocase: String
  denominationOracle_ends_with: String
  denominationOracle_ends_with_nocase: String
  denominationOracle_not_ends_with: String
  denominationOracle_not_ends_with_nocase: String
  denominationOracle_: Oracle_filter
  tokenPair: String
  tokenPair_not: String
  tokenPair_gt: String
  tokenPair_lt: String
  tokenPair_gte: String
  tokenPair_lte: String
  tokenPair_in: [String!]
  tokenPair_not_in: [String!]
  tokenPair_contains: String
  tokenPair_contains_nocase: String
  tokenPair_not_contains: String
  tokenPair_not_contains_nocase: String
  tokenPair_starts_with: String
  tokenPair_starts_with_nocase: String
  tokenPair_not_starts_with: String
  tokenPair_not_starts_with_nocase: String
  tokenPair_ends_with: String
  tokenPair_ends_with_nocase: String
  tokenPair_not_ends_with: String
  tokenPair_not_ends_with_nocase: String
  tokenPair_: DerivedTokenPair_filter
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  prices_: DerivedPrice_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DerivedOracle_filter]
  or: [DerivedOracle_filter]
}

enum DerivedOracle_orderBy {
  id
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  denomination
  denomination__id
  denomination__address
  denomination__symbol
  denomination__decimals
  denomination__precision
  tokenOracle
  tokenOracle__id
  tokenOracle__address
  tokenOracle__description
  tokenOracle__phaseId
  denominationOracle
  denominationOracle__id
  denominationOracle__address
  denominationOracle__description
  denominationOracle__phaseId
  tokenPair
  tokenPair__id
  tokenPair__description
  description
  prices
}

type DerivedPrice {
  id: Bytes!
  tokenPair: DerivedTokenPair!
  tokenTimestamp: BigInt!
  tokenRoundId: BigInt!
  tokenPrice: BigInt!
  denominationTimestamp: BigInt!
  denominationRoundId: BigInt!
  denominationPrice: BigInt!
  derivedPrice: BigInt!
  oracle: DerivedOracle!
  oracleType: String!
  token: Token!
  denomination: Token!
  hour: BigInt
  day: BigInt
  month: BigInt
  year: BigInt
}

input DerivedPrice_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  tokenPair: String
  tokenPair_not: String
  tokenPair_gt: String
  tokenPair_lt: String
  tokenPair_gte: String
  tokenPair_lte: String
  tokenPair_in: [String!]
  tokenPair_not_in: [String!]
  tokenPair_contains: String
  tokenPair_contains_nocase: String
  tokenPair_not_contains: String
  tokenPair_not_contains_nocase: String
  tokenPair_starts_with: String
  tokenPair_starts_with_nocase: String
  tokenPair_not_starts_with: String
  tokenPair_not_starts_with_nocase: String
  tokenPair_ends_with: String
  tokenPair_ends_with_nocase: String
  tokenPair_not_ends_with: String
  tokenPair_not_ends_with_nocase: String
  tokenPair_: DerivedTokenPair_filter
  tokenTimestamp: BigInt
  tokenTimestamp_not: BigInt
  tokenTimestamp_gt: BigInt
  tokenTimestamp_lt: BigInt
  tokenTimestamp_gte: BigInt
  tokenTimestamp_lte: BigInt
  tokenTimestamp_in: [BigInt!]
  tokenTimestamp_not_in: [BigInt!]
  tokenRoundId: BigInt
  tokenRoundId_not: BigInt
  tokenRoundId_gt: BigInt
  tokenRoundId_lt: BigInt
  tokenRoundId_gte: BigInt
  tokenRoundId_lte: BigInt
  tokenRoundId_in: [BigInt!]
  tokenRoundId_not_in: [BigInt!]
  tokenPrice: BigInt
  tokenPrice_not: BigInt
  tokenPrice_gt: BigInt
  tokenPrice_lt: BigInt
  tokenPrice_gte: BigInt
  tokenPrice_lte: BigInt
  tokenPrice_in: [BigInt!]
  tokenPrice_not_in: [BigInt!]
  denominationTimestamp: BigInt
  denominationTimestamp_not: BigInt
  denominationTimestamp_gt: BigInt
  denominationTimestamp_lt: BigInt
  denominationTimestamp_gte: BigInt
  denominationTimestamp_lte: BigInt
  denominationTimestamp_in: [BigInt!]
  denominationTimestamp_not_in: [BigInt!]
  denominationRoundId: BigInt
  denominationRoundId_not: BigInt
  denominationRoundId_gt: BigInt
  denominationRoundId_lt: BigInt
  denominationRoundId_gte: BigInt
  denominationRoundId_lte: BigInt
  denominationRoundId_in: [BigInt!]
  denominationRoundId_not_in: [BigInt!]
  denominationPrice: BigInt
  denominationPrice_not: BigInt
  denominationPrice_gt: BigInt
  denominationPrice_lt: BigInt
  denominationPrice_gte: BigInt
  denominationPrice_lte: BigInt
  denominationPrice_in: [BigInt!]
  denominationPrice_not_in: [BigInt!]
  derivedPrice: BigInt
  derivedPrice_not: BigInt
  derivedPrice_gt: BigInt
  derivedPrice_lt: BigInt
  derivedPrice_gte: BigInt
  derivedPrice_lte: BigInt
  derivedPrice_in: [BigInt!]
  derivedPrice_not_in: [BigInt!]
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: DerivedOracle_filter
  oracleType: String
  oracleType_not: String
  oracleType_gt: String
  oracleType_lt: String
  oracleType_gte: String
  oracleType_lte: String
  oracleType_in: [String!]
  oracleType_not_in: [String!]
  oracleType_contains: String
  oracleType_contains_nocase: String
  oracleType_not_contains: String
  oracleType_not_contains_nocase: String
  oracleType_starts_with: String
  oracleType_starts_with_nocase: String
  oracleType_not_starts_with: String
  oracleType_not_starts_with_nocase: String
  oracleType_ends_with: String
  oracleType_ends_with_nocase: String
  oracleType_not_ends_with: String
  oracleType_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  denomination: String
  denomination_not: String
  denomination_gt: String
  denomination_lt: String
  denomination_gte: String
  denomination_lte: String
  denomination_in: [String!]
  denomination_not_in: [String!]
  denomination_contains: String
  denomination_contains_nocase: String
  denomination_not_contains: String
  denomination_not_contains_nocase: String
  denomination_starts_with: String
  denomination_starts_with_nocase: String
  denomination_not_starts_with: String
  denomination_not_starts_with_nocase: String
  denomination_ends_with: String
  denomination_ends_with_nocase: String
  denomination_not_ends_with: String
  denomination_not_ends_with_nocase: String
  denomination_: Token_filter
  hour: BigInt
  hour_not: BigInt
  hour_gt: BigInt
  hour_lt: BigInt
  hour_gte: BigInt
  hour_lte: BigInt
  hour_in: [BigInt!]
  hour_not_in: [BigInt!]
  day: BigInt
  day_not: BigInt
  day_gt: BigInt
  day_lt: BigInt
  day_gte: BigInt
  day_lte: BigInt
  day_in: [BigInt!]
  day_not_in: [BigInt!]
  month: BigInt
  month_not: BigInt
  month_gt: BigInt
  month_lt: BigInt
  month_gte: BigInt
  month_lte: BigInt
  month_in: [BigInt!]
  month_not_in: [BigInt!]
  year: BigInt
  year_not: BigInt
  year_gt: BigInt
  year_lt: BigInt
  year_gte: BigInt
  year_lte: BigInt
  year_in: [BigInt!]
  year_not_in: [BigInt!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DerivedPrice_filter]
  or: [DerivedPrice_filter]
}

enum DerivedPrice_orderBy {
  id
  tokenPair
  tokenPair__id
  tokenPair__description
  tokenTimestamp
  tokenRoundId
  tokenPrice
  denominationTimestamp
  denominationRoundId
  denominationPrice
  derivedPrice
  oracle
  oracle__id
  oracle__description
  oracleType
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  denomination
  denomination__id
  denomination__address
  denomination__symbol
  denomination__decimals
  denomination__precision
  hour
  day
  month
  year
}

type DerivedTokenPair {
  id: Bytes!
  description: String!
  oracle: DerivedOracle!
  token: Token!
  denomination: Token!
  prices(skip: Int = 0, first: Int = 100, orderBy: DerivedPrice_orderBy, orderDirection: OrderDirection, where: DerivedPrice_filter): [DerivedPrice!]!
}

input DerivedTokenPair_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: DerivedOracle_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  denomination: String
  denomination_not: String
  denomination_gt: String
  denomination_lt: String
  denomination_gte: String
  denomination_lte: String
  denomination_in: [String!]
  denomination_not_in: [String!]
  denomination_contains: String
  denomination_contains_nocase: String
  denomination_not_contains: String
  denomination_not_contains_nocase: String
  denomination_starts_with: String
  denomination_starts_with_nocase: String
  denomination_not_starts_with: String
  denomination_not_starts_with_nocase: String
  denomination_ends_with: String
  denomination_ends_with_nocase: String
  denomination_not_ends_with: String
  denomination_not_ends_with_nocase: String
  denomination_: Token_filter
  prices_: DerivedPrice_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [DerivedTokenPair_filter]
  or: [DerivedTokenPair_filter]
}

enum DerivedTokenPair_orderBy {
  id
  description
  oracle
  oracle__id
  oracle__description
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  denomination
  denomination__id
  denomination__address
  denomination__symbol
  denomination__decimals
  denomination__precision
  prices
}

"""
8 bytes signed integer

"""
scalar Int8

type LatestPrice {
  id: Bytes!
  timestamp: BigInt!
  price: BigInt!
  oracle: Oracle!
  roundId: BigInt!
  aggregatorRoundId: BigInt!
  phaseId: Int
}

input LatestPrice_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: Oracle_filter
  roundId: BigInt
  roundId_not: BigInt
  roundId_gt: BigInt
  roundId_lt: BigInt
  roundId_gte: BigInt
  roundId_lte: BigInt
  roundId_in: [BigInt!]
  roundId_not_in: [BigInt!]
  aggregatorRoundId: BigInt
  aggregatorRoundId_not: BigInt
  aggregatorRoundId_gt: BigInt
  aggregatorRoundId_lt: BigInt
  aggregatorRoundId_gte: BigInt
  aggregatorRoundId_lte: BigInt
  aggregatorRoundId_in: [BigInt!]
  aggregatorRoundId_not_in: [BigInt!]
  phaseId: Int
  phaseId_not: Int
  phaseId_gt: Int
  phaseId_lt: Int
  phaseId_gte: Int
  phaseId_lte: Int
  phaseId_in: [Int!]
  phaseId_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [LatestPrice_filter]
  or: [LatestPrice_filter]
}

enum LatestPrice_orderBy {
  id
  timestamp
  price
  oracle
  oracle__id
  oracle__address
  oracle__description
  oracle__phaseId
  roundId
  aggregatorRoundId
  phaseId
}

type Oracle {
  id: Bytes!
  address: Bytes!
  token: Token!
  denomination: Token!
  tokenPair: TokenPair!
  description: String!
  phaseId: Int!
  aggregator: OracleAggregator!
  prices(skip: Int = 0, first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, where: Price_filter): [Price!]!
}

input Oracle_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  denomination: String
  denomination_not: String
  denomination_gt: String
  denomination_lt: String
  denomination_gte: String
  denomination_lte: String
  denomination_in: [String!]
  denomination_not_in: [String!]
  denomination_contains: String
  denomination_contains_nocase: String
  denomination_not_contains: String
  denomination_not_contains_nocase: String
  denomination_starts_with: String
  denomination_starts_with_nocase: String
  denomination_not_starts_with: String
  denomination_not_starts_with_nocase: String
  denomination_ends_with: String
  denomination_ends_with_nocase: String
  denomination_not_ends_with: String
  denomination_not_ends_with_nocase: String
  denomination_: Token_filter
  tokenPair: String
  tokenPair_not: String
  tokenPair_gt: String
  tokenPair_lt: String
  tokenPair_gte: String
  tokenPair_lte: String
  tokenPair_in: [String!]
  tokenPair_not_in: [String!]
  tokenPair_contains: String
  tokenPair_contains_nocase: String
  tokenPair_not_contains: String
  tokenPair_not_contains_nocase: String
  tokenPair_starts_with: String
  tokenPair_starts_with_nocase: String
  tokenPair_not_starts_with: String
  tokenPair_not_starts_with_nocase: String
  tokenPair_ends_with: String
  tokenPair_ends_with_nocase: String
  tokenPair_not_ends_with: String
  tokenPair_not_ends_with_nocase: String
  tokenPair_: TokenPair_filter
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  phaseId: Int
  phaseId_not: Int
  phaseId_gt: Int
  phaseId_lt: Int
  phaseId_gte: Int
  phaseId_lte: Int
  phaseId_in: [Int!]
  phaseId_not_in: [Int!]
  aggregator: String
  aggregator_not: String
  aggregator_gt: String
  aggregator_lt: String
  aggregator_gte: String
  aggregator_lte: String
  aggregator_in: [String!]
  aggregator_not_in: [String!]
  aggregator_contains: String
  aggregator_contains_nocase: String
  aggregator_not_contains: String
  aggregator_not_contains_nocase: String
  aggregator_starts_with: String
  aggregator_starts_with_nocase: String
  aggregator_not_starts_with: String
  aggregator_not_starts_with_nocase: String
  aggregator_ends_with: String
  aggregator_ends_with_nocase: String
  aggregator_not_ends_with: String
  aggregator_not_ends_with_nocase: String
  aggregator_: OracleAggregator_filter
  prices_: Price_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Oracle_filter]
  or: [Oracle_filter]
}

enum Oracle_orderBy {
  id
  address
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  denomination
  denomination__id
  denomination__address
  denomination__symbol
  denomination__decimals
  denomination__precision
  tokenPair
  tokenPair__id
  tokenPair__description
  description
  phaseId
  aggregator
  aggregator__id
  aggregator__address
  prices
}

type OracleAggregator {
  id: Bytes!
  oracle: Oracle!
  address: Bytes!
}

input OracleAggregator_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: Oracle_filter
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [OracleAggregator_filter]
  or: [OracleAggregator_filter]
}

enum OracleAggregator_orderBy {
  id
  oracle
  oracle__id
  oracle__address
  oracle__description
  oracle__phaseId
  address
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Price {
  id: Bytes!
  tokenPair: TokenPair!
  timestamp: BigInt!
  price: BigInt!
  oracle: Oracle!
  oracleType: String!
  token: Token!
  hour: BigInt
  day: BigInt
  month: BigInt
  year: BigInt
  roundId: BigInt
  aggregatorRoundId: BigInt
  phaseId: Int
}

input Price_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  tokenPair: String
  tokenPair_not: String
  tokenPair_gt: String
  tokenPair_lt: String
  tokenPair_gte: String
  tokenPair_lte: String
  tokenPair_in: [String!]
  tokenPair_not_in: [String!]
  tokenPair_contains: String
  tokenPair_contains_nocase: String
  tokenPair_not_contains: String
  tokenPair_not_contains_nocase: String
  tokenPair_starts_with: String
  tokenPair_starts_with_nocase: String
  tokenPair_not_starts_with: String
  tokenPair_not_starts_with_nocase: String
  tokenPair_ends_with: String
  tokenPair_ends_with_nocase: String
  tokenPair_not_ends_with: String
  tokenPair_not_ends_with_nocase: String
  tokenPair_: TokenPair_filter
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: Oracle_filter
  oracleType: String
  oracleType_not: String
  oracleType_gt: String
  oracleType_lt: String
  oracleType_gte: String
  oracleType_lte: String
  oracleType_in: [String!]
  oracleType_not_in: [String!]
  oracleType_contains: String
  oracleType_contains_nocase: String
  oracleType_not_contains: String
  oracleType_not_contains_nocase: String
  oracleType_starts_with: String
  oracleType_starts_with_nocase: String
  oracleType_not_starts_with: String
  oracleType_not_starts_with_nocase: String
  oracleType_ends_with: String
  oracleType_ends_with_nocase: String
  oracleType_not_ends_with: String
  oracleType_not_ends_with_nocase: String
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  hour: BigInt
  hour_not: BigInt
  hour_gt: BigInt
  hour_lt: BigInt
  hour_gte: BigInt
  hour_lte: BigInt
  hour_in: [BigInt!]
  hour_not_in: [BigInt!]
  day: BigInt
  day_not: BigInt
  day_gt: BigInt
  day_lt: BigInt
  day_gte: BigInt
  day_lte: BigInt
  day_in: [BigInt!]
  day_not_in: [BigInt!]
  month: BigInt
  month_not: BigInt
  month_gt: BigInt
  month_lt: BigInt
  month_gte: BigInt
  month_lte: BigInt
  month_in: [BigInt!]
  month_not_in: [BigInt!]
  year: BigInt
  year_not: BigInt
  year_gt: BigInt
  year_lt: BigInt
  year_gte: BigInt
  year_lte: BigInt
  year_in: [BigInt!]
  year_not_in: [BigInt!]
  roundId: BigInt
  roundId_not: BigInt
  roundId_gt: BigInt
  roundId_lt: BigInt
  roundId_gte: BigInt
  roundId_lte: BigInt
  roundId_in: [BigInt!]
  roundId_not_in: [BigInt!]
  aggregatorRoundId: BigInt
  aggregatorRoundId_not: BigInt
  aggregatorRoundId_gt: BigInt
  aggregatorRoundId_lt: BigInt
  aggregatorRoundId_gte: BigInt
  aggregatorRoundId_lte: BigInt
  aggregatorRoundId_in: [BigInt!]
  aggregatorRoundId_not_in: [BigInt!]
  phaseId: Int
  phaseId_not: Int
  phaseId_gt: Int
  phaseId_lt: Int
  phaseId_gte: Int
  phaseId_lte: Int
  phaseId_in: [Int!]
  phaseId_not_in: [Int!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Price_filter]
  or: [Price_filter]
}

enum Price_orderBy {
  id
  tokenPair
  tokenPair__id
  tokenPair__description
  timestamp
  price
  oracle
  oracle__id
  oracle__address
  oracle__description
  oracle__phaseId
  oracleType
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  hour
  day
  month
  year
  roundId
  aggregatorRoundId
  phaseId
}

type Query {
  state(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): State
  states(
    skip: Int = 0
    first: Int = 100
    orderBy: State_orderBy
    orderDirection: OrderDirection
    where: State_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [State!]!
  price(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Price
  prices(
    skip: Int = 0
    first: Int = 100
    orderBy: Price_orderBy
    orderDirection: OrderDirection
    where: Price_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Price!]!
  latestPrice(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    where: LatestPrice_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LatestPrice!]!
  derivedPrice(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedPrice
  derivedPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedPrice_orderBy
    orderDirection: OrderDirection
    where: DerivedPrice_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedPrice!]!
  tokenPair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPair
  tokenPairs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPair_orderBy
    orderDirection: OrderDirection
    where: TokenPair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenPair!]!
  derivedTokenPair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedTokenPair
  derivedTokenPairs(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedTokenPair_orderBy
    orderDirection: OrderDirection
    where: DerivedTokenPair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedTokenPair!]!
  oracle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Oracle
  oracles(
    skip: Int = 0
    first: Int = 100
    orderBy: Oracle_orderBy
    orderDirection: OrderDirection
    where: Oracle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Oracle!]!
  oracleAggregator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OracleAggregator
  oracleAggregators(
    skip: Int = 0
    first: Int = 100
    orderBy: OracleAggregator_orderBy
    orderDirection: OrderDirection
    where: OracleAggregator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OracleAggregator!]!
  derivedOracle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedOracle
  derivedOracles(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedOracle_orderBy
    orderDirection: OrderDirection
    where: DerivedOracle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedOracle!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  answerUpdated(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AnswerUpdated
  answerUpdateds(
    skip: Int = 0
    first: Int = 100
    orderBy: AnswerUpdated_orderBy
    orderDirection: OrderDirection
    where: AnswerUpdated_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AnswerUpdated!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type State {
  id: Bytes!
  lastOneInchUpdateTimestamp: BigInt
  lastAggregatorUpdateTimestamp: BigInt
  oraclesInitialized: Boolean!
}

input State_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  lastOneInchUpdateTimestamp: BigInt
  lastOneInchUpdateTimestamp_not: BigInt
  lastOneInchUpdateTimestamp_gt: BigInt
  lastOneInchUpdateTimestamp_lt: BigInt
  lastOneInchUpdateTimestamp_gte: BigInt
  lastOneInchUpdateTimestamp_lte: BigInt
  lastOneInchUpdateTimestamp_in: [BigInt!]
  lastOneInchUpdateTimestamp_not_in: [BigInt!]
  lastAggregatorUpdateTimestamp: BigInt
  lastAggregatorUpdateTimestamp_not: BigInt
  lastAggregatorUpdateTimestamp_gt: BigInt
  lastAggregatorUpdateTimestamp_lt: BigInt
  lastAggregatorUpdateTimestamp_gte: BigInt
  lastAggregatorUpdateTimestamp_lte: BigInt
  lastAggregatorUpdateTimestamp_in: [BigInt!]
  lastAggregatorUpdateTimestamp_not_in: [BigInt!]
  oraclesInitialized: Boolean
  oraclesInitialized_not: Boolean
  oraclesInitialized_in: [Boolean!]
  oraclesInitialized_not_in: [Boolean!]

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [State_filter]
  or: [State_filter]
}

enum State_orderBy {
  id
  lastOneInchUpdateTimestamp
  lastAggregatorUpdateTimestamp
  oraclesInitialized
}

type Subscription {
  state(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): State
  states(
    skip: Int = 0
    first: Int = 100
    orderBy: State_orderBy
    orderDirection: OrderDirection
    where: State_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [State!]!
  price(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Price
  prices(
    skip: Int = 0
    first: Int = 100
    orderBy: Price_orderBy
    orderDirection: OrderDirection
    where: Price_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Price!]!
  latestPrice(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): LatestPrice
  latestPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: LatestPrice_orderBy
    orderDirection: OrderDirection
    where: LatestPrice_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [LatestPrice!]!
  derivedPrice(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedPrice
  derivedPrices(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedPrice_orderBy
    orderDirection: OrderDirection
    where: DerivedPrice_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedPrice!]!
  tokenPair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenPair
  tokenPairs(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenPair_orderBy
    orderDirection: OrderDirection
    where: TokenPair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenPair!]!
  derivedTokenPair(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedTokenPair
  derivedTokenPairs(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedTokenPair_orderBy
    orderDirection: OrderDirection
    where: DerivedTokenPair_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedTokenPair!]!
  oracle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Oracle
  oracles(
    skip: Int = 0
    first: Int = 100
    orderBy: Oracle_orderBy
    orderDirection: OrderDirection
    where: Oracle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Oracle!]!
  oracleAggregator(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): OracleAggregator
  oracleAggregators(
    skip: Int = 0
    first: Int = 100
    orderBy: OracleAggregator_orderBy
    orderDirection: OrderDirection
    where: OracleAggregator_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [OracleAggregator!]!
  derivedOracle(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): DerivedOracle
  derivedOracles(
    skip: Int = 0
    first: Int = 100
    orderBy: DerivedOracle_orderBy
    orderDirection: OrderDirection
    where: DerivedOracle_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [DerivedOracle!]!
  token(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  answerUpdated(
    id: ID!

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): AnswerUpdated
  answerUpdateds(
    skip: Int = 0
    first: Int = 100
    orderBy: AnswerUpdated_orderBy
    orderDirection: OrderDirection
    where: AnswerUpdated_filter

    """
    The block at which the query should be executed. Can either be a `{ hash:
    Bytes }` value containing a block hash, a `{ number: Int }` containing the
    block number, or a `{ number_gte: Int }` containing the minimum block
    number. In the case of `number_gte`, the query will be executed on the
    latest block only if the subgraph has progressed to or past the minimum
    block number. Defaults to the latest block when omitted.
    """
    block: Block_height

    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [AnswerUpdated!]!

  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Token {
  id: Bytes!
  address: Bytes!
  symbol: String!
  decimals: BigInt!
  precision: BigInt!
  oraclesToken(skip: Int = 0, first: Int = 100, orderBy: Oracle_orderBy, orderDirection: OrderDirection, where: Oracle_filter): [Oracle!]!
  oraclesDenomination(skip: Int = 0, first: Int = 100, orderBy: Oracle_orderBy, orderDirection: OrderDirection, where: Oracle_filter): [Oracle!]!
  tokenPairs(skip: Int = 0, first: Int = 100, orderBy: TokenPair_orderBy, orderDirection: OrderDirection, where: TokenPair_filter): [TokenPair!]!
  prices(skip: Int = 0, first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, where: Price_filter): [Price!]!
  relatedTokens(skip: Int = 0, first: Int = 100, orderBy: Token_orderBy, orderDirection: OrderDirection, where: Token_filter): [Token!]
}

input Token_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  address: Bytes
  address_not: Bytes
  address_gt: Bytes
  address_lt: Bytes
  address_gte: Bytes
  address_lte: Bytes
  address_in: [Bytes!]
  address_not_in: [Bytes!]
  address_contains: Bytes
  address_not_contains: Bytes
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: BigInt
  decimals_not: BigInt
  decimals_gt: BigInt
  decimals_lt: BigInt
  decimals_gte: BigInt
  decimals_lte: BigInt
  decimals_in: [BigInt!]
  decimals_not_in: [BigInt!]
  precision: BigInt
  precision_not: BigInt
  precision_gt: BigInt
  precision_lt: BigInt
  precision_gte: BigInt
  precision_lte: BigInt
  precision_in: [BigInt!]
  precision_not_in: [BigInt!]
  oraclesToken_: Oracle_filter
  oraclesDenomination_: Oracle_filter
  tokenPairs_: TokenPair_filter
  prices_: Price_filter
  relatedTokens: [String!]
  relatedTokens_not: [String!]
  relatedTokens_contains: [String!]
  relatedTokens_contains_nocase: [String!]
  relatedTokens_not_contains: [String!]
  relatedTokens_not_contains_nocase: [String!]
  relatedTokens_: Token_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  address
  symbol
  decimals
  precision
  oraclesToken
  oraclesDenomination
  tokenPairs
  prices
  relatedTokens
}

type TokenPair {
  id: Bytes!
  description: String!
  oracle: Oracle!
  token: Token!
  denomination: Token!
  prices(skip: Int = 0, first: Int = 100, orderBy: Price_orderBy, orderDirection: OrderDirection, where: Price_filter): [Price!]!
}

input TokenPair_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  oracle: String
  oracle_not: String
  oracle_gt: String
  oracle_lt: String
  oracle_gte: String
  oracle_lte: String
  oracle_in: [String!]
  oracle_not_in: [String!]
  oracle_contains: String
  oracle_contains_nocase: String
  oracle_not_contains: String
  oracle_not_contains_nocase: String
  oracle_starts_with: String
  oracle_starts_with_nocase: String
  oracle_not_starts_with: String
  oracle_not_starts_with_nocase: String
  oracle_ends_with: String
  oracle_ends_with_nocase: String
  oracle_not_ends_with: String
  oracle_not_ends_with_nocase: String
  oracle_: Oracle_filter
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  denomination: String
  denomination_not: String
  denomination_gt: String
  denomination_lt: String
  denomination_gte: String
  denomination_lte: String
  denomination_in: [String!]
  denomination_not_in: [String!]
  denomination_contains: String
  denomination_contains_nocase: String
  denomination_not_contains: String
  denomination_not_contains_nocase: String
  denomination_starts_with: String
  denomination_starts_with_nocase: String
  denomination_not_starts_with: String
  denomination_not_starts_with_nocase: String
  denomination_ends_with: String
  denomination_ends_with_nocase: String
  denomination_not_ends_with: String
  denomination_not_ends_with_nocase: String
  denomination_: Token_filter
  prices_: Price_filter

  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenPair_filter]
  or: [TokenPair_filter]
}

enum TokenPair_orderBy {
  id
  description
  oracle
  oracle__id
  oracle__address
  oracle__description
  oracle__phaseId
  token
  token__id
  token__address
  token__symbol
  token__decimals
  token__precision
  denomination
  denomination__id
  denomination__address
  denomination__symbol
  denomination__decimals
  denomination__precision
  prices
}

